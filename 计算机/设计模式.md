# 设计模式

## 六大原则

### 单一职责原则

（Single Responsibility Principle）

运用位置：方法，类，接口

#### 定义

应该 <mark>有且仅有</mark> 一个原因引起类的变更。

通俗点理解，就是一个类要修改，只能通过修改一处地方的代码进行修改

#### 举例

这里我们写一个打电话的类，电话通话的时候有 4 个过程发生：拨号、通话、接电话、挂电话。那我们写一个接口

```java
public inteface IPhone{

    //拨号接电话
    public void dial(String phoneNumber);
    //挂电话
     public void hangup();
    //通话
     public void chat(Object o);
    
    
}


```

类图如下![image-20230918192449363](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230918192449363.png)

这里分析可以知道 拨号并接通电话和挂电话是一个<mark>动作行为</mark>方法  而通话是一个<mark>数据传输</mark>方法，这两种方法执行的职责不统一，我们要接口必须功能统一起来才能算是完成单一隔离原则。

要想上面的实现单一原则功能，我们可以这样做。将父接口分离为两个子接口分别是IConnetionManager，IDataTransfer 类图如下图![image-20230918192224312](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230918192224312.png)

这样动作行为功能跟数据传输功能就分开了，实现了接口上的单一职责原则，另外，单一职责原则不仅适用于接口和类，也适用于方法。一个方法尽可能只做一件事，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。

#### 优点

一个类的复杂性降低，实现的功能都清晰明确的定义

可读性高，复杂性降低，可读性自然高

可维护性高，可读性高，可维护性自然高

重构变更风险降低，重构变更必不可少，如果接口的单一职责做的好，一个接口修改只对它自己的实现类有影响，对其他接口无影响，那么可读性跟可扩展，维护性都有非常大的帮助

### 开闭原则

（Open Closed Principle）

### 里氏替换原则

（Liskov Substitution Principle）

运用位置：类，接口

#### 定义

如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。

通俗点理解 两个对象o1、o2，将程序中的所有o1代替成o2，程序功能不发生改变，那么o1类型就是o2类型的子类

就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。

#### 举例

里氏替换原则为良好的继承定义了一个规范，要实现里氏替换原则必须遵守下面四条标准，一句简单的定义包含了4层含义。

##### 1. 子类必须完全实现父类的方法。

##### 2. 孩子类可以有自己的个性。

##### 3. 覆盖或实现父类的方法时，输入参数可以被放大。

##### 4. 覆盖或实现父类的方法时，输出结果可以被缩小。

#### 优点

### 迪米特法则

（Law of Demeter），又叫“最少知道法则”

### 接口隔离原则

（Interface Segregation Principle）

### 依赖倒置原则

（Dependence Inversion Principle）





## 23种设计模式